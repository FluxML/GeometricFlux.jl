<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../../../../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/'</script><script charset="utf-8" src="../../../../../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../../../../../assets/default/flexsearch_integration.js" type="text/javascript"></script><script charset="utf-8" src="../../../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/'</script><script charset="utf-8" src="../../../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Sparse graph strucutre · GraphSignals.jl</title><link href="https://yuehhua.github.io/GraphSignals.jl/stable/manual/sparsegraph/" rel="canonical"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><link href="../../../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/><link href="../../../../../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../../../../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><a class="nav-link active nav-item" href="../../../../../">GeometricFlux</a><a class="nav-link nav-item" href="../../../../../../graphsignals/stable/">GraphSignals</a><div class="search nav-item"><input id="search-input" placeholder="Search..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><a class="nav-link nav-item" href="../../../../geometricflux/">GeometricFlux</a><a class="nav-link active nav-item" href="../../../stable/">GraphSignals</a><div class="search nav-item"><input id="search-input" placeholder="Search..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GraphSignals.jl</span></div><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../featuredgraph/">FeaturedGraph</a></li><li class="is-active"><a class="tocitem" href="">Sparse graph strucutre</a><ul class="internal"><li><a class="tocitem" href="#The-need-of-graph-structure"><span>The need of graph structure</span></a></li><li><a class="tocitem" href="#SparseGraph"><span><code>SparseGraph</code></span></a></li><li><a class="tocitem" href="#Create-SparseGraph"><span>Create <code>SparseGraph</code></span></a></li><li><a class="tocitem" href="#Operate-SparseGraph-as-graph"><span>Operate <code>SparseGraph</code> as graph</span></a></li><li><a class="tocitem" href="#Indexing-operations"><span>Indexing operations</span></a></li><li><a class="tocitem" href="#Aggregate-over-neighbors"><span>Aggregate over neighbors</span></a></li><li><a class="tocitem" href="#SparseGraph-APIs"><span><code>SparseGraph</code> APIs</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="">Sparse graph strucutre</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Sparse graph strucutre</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/yuehhua/GraphSignals.jl/blob/master/docs/src/manual/sparsegraph.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-graph-Strucutre"><a class="docs-heading-anchor" href="#Sparse-graph-Strucutre">Sparse graph Strucutre</a><a id="Sparse-graph-Strucutre-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-graph-Strucutre" title="Permalink"></a></h1><h2 id="The-need-of-graph-structure"><a class="docs-heading-anchor" href="#The-need-of-graph-structure">The need of graph structure</a><a id="The-need-of-graph-structure-1"></a><a class="docs-heading-anchor-permalink" href="#The-need-of-graph-structure" title="Permalink"></a></h2><p>Graph convolution can be classified into spectral-based graph convolution and spatial-based graph convolution. Spectral-based graph convolution relys on the algebaric operations, including <code>+</code>, <code>-</code>, <code>*</code>, which are applied to features with graph structure. Spatial-based graph convolution relys on the indexing operations, since spatial-based graph convolution always indexes the neighbors of vertex. A graph structure can be use under two view point of a part of algebaric operations or an indexing structure.</p><p>Message-passing neural network requires to access neighbor information for each vertex. Messages are passed from a vertex's neighbors to itself. A efficient indexing data structure is required to access incident edges or neighbor vertices from a specific vertex.</p><h2 id="SparseGraph"><a class="docs-heading-anchor" href="#SparseGraph"><code>SparseGraph</code></a><a id="SparseGraph-1"></a><a class="docs-heading-anchor-permalink" href="#SparseGraph" title="Permalink"></a></h2><p>SparseGraph is implemented with sparse matrix. It is built on top of built-in sparse matrix, <code>SparseMatrixCSC</code>. <code>SparseMatrixCSC</code> can be used as a regular matrix and performs algebaric operations with matrix or vectors.</p><p>To benefit message-passing scheme, making a graph structure as an indexing structure is important. A well-designed indexing structure is made to leverage the sparse format of <code>SparseMatrixCSC</code>, which is in CSC format. CSC format stores sparse matrix in a highly compressed manner. Comparing to traditional COO format, CSC format compresses the column indices into column pointers. All values are stored in single vector. If we want to index the sparse matrix <code>A</code>, the row indices can be fetched by <code>rowvals[colptr[j]:(colptr[j+1]-1)]</code> and the non-zero values can be indexed by <code>nzvals[colptr[j]:(colptr[j+1]-1)]</code>. The edge indices are designed in the same manner <code>edges[colptr[j]:(colptr[j+1]-1)]</code>. This way matches the need of indexing neighbors of vertex. This makes neighbor indices or values close together. It takes <span>$O(1)$</span> to get negihbor indices, instead of searching neighbor in <span>$O(N)$</span>. Thus, <code>SparseGraph</code> takes both advantages of both algebaric operations and indexing operations.</p><h2 id="Create-SparseGraph"><a class="docs-heading-anchor" href="#Create-SparseGraph">Create <code>SparseGraph</code></a><a id="Create-SparseGraph-1"></a><a class="docs-heading-anchor-permalink" href="#Create-SparseGraph" title="Permalink"></a></h2><p><code>SparseGraph</code> accepts adjacency matrix, adjacency list, and almost all graphs defined in JuliaGraphs.</p><pre><code class="language-julia">julia&gt; using GraphSignals, LightGraphs

julia&gt; ug = SimpleGraph(4)
{4, 0} undirected simple Int64 graph

julia&gt; add_edge!(ug, 1, 2); add_edge!(ug, 1, 3); add_edge!(ug, 1, 4);

julia&gt; add_edge!(ug, 2, 3); add_edge!(ug, 3, 4);

julia&gt; sg = SparseGraph(ug)
SparseGraph(#V=4, #E=5)</code></pre><p>The indexed adjacency list is a list of list strucutre. The inner list consists of a series of tuples containing a vertex index and a edge index, respectively.</p><h2 id="Operate-SparseGraph-as-graph"><a class="docs-heading-anchor" href="#Operate-SparseGraph-as-graph">Operate <code>SparseGraph</code> as graph</a><a id="Operate-SparseGraph-as-graph-1"></a><a class="docs-heading-anchor-permalink" href="#Operate-SparseGraph-as-graph" title="Permalink"></a></h2><p>It supports basic graph APIs for querying graph information, including number of vertices <code>nv</code> and number of edges <code>ne</code>.</p><pre><code class="language-julia">julia&gt; is_directed(sg)
false

julia&gt; nv(sg)
4

julia&gt; ne(sg)
5

julia&gt; eltype(sg)
Int64

julia&gt; has_vertex(sg, 3)
true

julia&gt; has_edge(sg, 1, 2)
true</code></pre><p>We can compare two graph structure if they are equivalent or not.</p><pre><code class="language-julia">julia&gt; adjm = [0 1 1 1; 1 0 1 0; 1 1 0 1; 1 0 1 0]
4×4 Matrix{Int64}:
 0  1  1  1
 1  0  1  0
 1  1  0  1
 1  0  1  0

julia&gt; sg2 = SparseGraph(adjm, false)
SparseGraph(#V=4, #E=5)

julia&gt; sg == sg2
true</code></pre><p>We can also iterate over edges.</p><pre><code class="language-julia">julia&gt; for (i, e) in edges(sg)
           println("edge index: ", i, ", edge: ", e)
       end
edge index: 1, edge: (2, 1)
edge index: 2, edge: (3, 1)
edge index: 3, edge: (3, 2)
edge index: 4, edge: (4, 1)
edge index: 5, edge: (4, 3)</code></pre><p>Edge index is the index for each edge. It is used to index edge features.</p><h2 id="Indexing-operations"><a class="docs-heading-anchor" href="#Indexing-operations">Indexing operations</a><a id="Indexing-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-operations" title="Permalink"></a></h2><p>To get neighbors of a specified vertex, <code>neighbors</code> is used by passing a <code>SparseGraph</code> object and a vertex index. A vector of neighbor vertex index is returned.</p><pre><code class="language-julia">julia&gt; neighbors(sg, 1)
3-element view(::Vector{Int64}, 1:3) with eltype Int64:
 2
 3
 4</code></pre><p>To get incident edges of a specified vertex, <code>incident_edges</code> can be used and it will return edge indices.</p><pre><code class="language-julia">julia&gt; incident_edges(sg, 1)
3-element view(::Vector{Int64}, 1:3) with eltype Int64:
 1
 2
 4</code></pre><p>An edge index can be fetched by querying an edge, for example, edge <code>(1, 2)</code> and edge <code>(2, 1)</code> refers to the same edge with index <code>1</code>.</p><pre><code class="language-julia">julia&gt; edge_index(sg, 1, 2)
1

julia&gt; edge_index(sg, 2, 1)
1</code></pre><p>One can have the opportunity to index the underlying sparse matrix.</p><pre><code class="language-julia">julia&gt; sg[1, 2]
1

julia&gt; sg[2, 1]
1</code></pre><h2 id="Aggregate-over-neighbors"><a class="docs-heading-anchor" href="#Aggregate-over-neighbors">Aggregate over neighbors</a><a id="Aggregate-over-neighbors-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregate-over-neighbors" title="Permalink"></a></h2><p>In message-passing scheme, it is always to aggregate node features or edge feature from neighbors. For convention, <code>edge_scatter</code> and <code>neighbor_scatter</code> are used to apply aggregate operations over edge features or neighbor vertex features. The actual aggregation is supported by <code>scatter</code> operations.</p><pre><code class="language-julia">julia&gt; nf = rand(10, 4);

julia&gt; neighbor_scatter(+, nf, sg)
10×4 Matrix{Float64}:
 1.54937   1.03974   1.72926  1.03974
 1.38554   0.775991  1.34106  0.775991
 1.13192   0.424888  1.34657  0.424888
 2.23452   1.63226   2.436    1.63226
 0.815662  0.718865  1.25237  0.718865
 2.35763   1.42174   2.26442  1.42174
 1.94051   1.44812   1.71694  1.44812
 1.83641   1.89104   1.80857  1.89104
 2.43027   1.92217   2.37003  1.92217
 1.58177   1.16149   1.87467  1.16149</code></pre><p>For example, <code>neighbor_scatter</code> aggregates node features <code>nf</code> via neighbors in graph <code>sg</code> by <code>+</code> operation.</p><pre><code class="language-julia">julia&gt; ef = rand(9, 5);

julia&gt; edge_scatter(+, ef, sg)
9×4 Matrix{Float64}:
 2.22577  0.967172  1.92781   1.92628
 1.4842   1.20605   2.30014   0.849819
 2.20728  1.01527   0.899094  1.35062
 1.09119  0.589925  1.62597   1.51175
 1.42288  1.63764   1.23445   0.693258
 1.57561  0.926591  1.72599   0.690108
 1.68402  0.544808  1.58687   1.70676
 1.10908  1.0898    1.05256   0.508157
 2.33764  1.26419   1.87927   1.11151</code></pre><p>Or, <code>edge_scatter</code> aggregates edge features <code>ef</code> via incident edges in graph <code>sg</code> by <code>+</code> operation.</p><h2 id="SparseGraph-APIs"><a class="docs-heading-anchor" href="#SparseGraph-APIs"><code>SparseGraph</code> APIs</a><a id="SparseGraph-APIs-1"></a><a class="docs-heading-anchor-permalink" href="#SparseGraph-APIs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#GraphSignals.SparseGraph" id="GraphSignals.SparseGraph"><code>GraphSignals.SparseGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SparseGraph(A, directed, [T])</code></pre><p>A sparse graph structure represents by sparse matrix. A directed graph is represented by a sparse matrix, of which column index as source node index and row index as sink node index.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Adjacency matrix.</li><li><code>directed</code>: If this is a directed graph or not.</li><li><code>T</code>: Element type for <code>SparseGraph</code>.</li></ul></div><a class="docs-sourcelink" href="https://github.com/yuehhua/GraphSignals.jl/blob/72990a2b63bc29ca4470755a2aa6127a9c8f324d/src/sparsegraph.jl#LL3-L15" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Graphs.neighbors" id="Graphs.neighbors"><code>Graphs.neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">neighbors(sg, i)</code></pre><p>Return the neighbors of vertex <code>i</code> in sparse graph <code>sg</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sg::SparseGraph</code>: sparse graph to query.</li><li><code>i</code>: vertex index.</li></ul></div><a class="docs-sourcelink" href="https://github.com/yuehhua/GraphSignals.jl/blob/72990a2b63bc29ca4470755a2aa6127a9c8f324d/src/sparsegraph.jl#LL153-L162" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#GraphSignals.incident_edges" id="GraphSignals.incident_edges"><code>GraphSignals.incident_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">incident_edges(sg, i)</code></pre><p>Return the edges incident to vertex <code>i</code> in sparse graph <code>sg</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sg::SparseGraph</code>: sparse graph to query.</li><li><code>i</code>: vertex index.</li></ul></div><a class="docs-sourcelink" href="https://github.com/yuehhua/GraphSignals.jl/blob/72990a2b63bc29ca4470755a2aa6127a9c8f324d/src/sparsegraph.jl#LL191-L200" target="_blank">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>neighbor_scatter</code>. Check Documenter's build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>edge_scatter</code>. Check Documenter's build log for details.</p></div></div><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><p>In the design of <code>SparseGraph</code>, it resolve the problem of indexing edge features. For a graph, edge is represented in <code>(i, j)</code> and edge features are considered as a matrix <code>ef</code> with edge number in its column. The problem is to unifiedly fetch corresponding edge feature <code>ef[:, k]</code> for edge <code>(i, j)</code> over directed and undirected graph. To resolve this issue, edge index is set to be the unique index for each edge. Further, <code>aggregate_index</code> is designed to generate indices for aggregating from neighbor nodes or incident edges. Conclusively, it provides the core operations needed in message-passing scheme.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../featuredgraph/">« FeaturedGraph</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 8 September 2022 10:55">Thursday 8 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>